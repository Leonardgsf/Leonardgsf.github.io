[{"id":"e5bcd557a969ca5425cbf4b6fbc100b6","title":"Mac开发大杀器之iTerm+NeoVim+Tmux","content":"Mac高效开发组合技iTermTmuxNeoVim","slug":"Mac开发大杀器之iTerm-NeoVim-Tmux","date":"2024-04-16T10:51:19.000Z","categories_index":"","tags_index":"","author_index":"Feng"},{"id":"3b39a4d8d73647456fc0c99c50fc60aa","title":"WebRTC 1对1实时音视频直播入门","content":"💡 设想一个情景：相隔两地的A和B，想进行音视频通信。应该怎么实现？\n当然，对于现在的人们来说，我们有很多的手段，包括常见的即时通信工具（QQ、微信）、腾讯会议、钉钉等，都可以轻松实现这个功能。\n那如果现在让你从零手动搭建一套远程一对一的音视频通信系统，应该怎么实现呢？\n不知道你脑海中有没有实现的思路。如果对这一领域比较陌生的同学，暂时莫慌，在下边的文章中我们会逐步拆解及介绍整个实现流程。希望学完这一课程，你会有一个比较清晰的脉络和学到可行的实践方案。\n话不多说，Let’s go！ 让我们开始今天的远程通信旅程吧~\n背景概要\n2011 年，Google 创立了 WebRTC 项目，其愿景就是可以在浏览器之间快速地实现音视频通信。\nWebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。\nWebRTC提供了视频会议的核心技术，包括音视频的采集、编解码、网络传输、显示等功能，并且还支持跨平台：windows，linux，mac，android。\n我们前期使用时知道基本的API就行，如果想继续了解，可以参照以下webrtc官方文档。\n\n步骤拆解\n既然通信的内容是音视频，肯定需要A、B各自的终端来检测、采集本地的音视频信息。\n采集完毕之后，A、B需要知道对方是否在线，确认对方已经准备好接收和传输音视频数据了。\nA、B双方需要沟通连接的信息及协议，方便建立通路。协商音视频编解码的格式，方便后续音视频渲染和播放。\n接下来就是最重要的点对点连接环节了，WebRTC提供的RTCPeerConnection会帮我们搞定一切。\n连接建立后，A、B的音视频数据在这条连接通路上要以直接方式各自不间断地传输到另一端。\n如果这个连接通路断掉的话，如何保障数据能稳定到达另一端呢？所以我们还要有一个中继服务器辅助双方完成音视频数据的中继及交换。\n最后音视频传输过来之后，要在各自客户端内进行解码、渲染、播放。\n\n个人理解，实现整个流程就是把各个细分的环节跑通，最后将所有环节自然串联运转起来的流程。接下来，让我们渗透到每一个环节中去分析解决方案。\n获取本地音视频信息\n音视频采集基本概念\n摄像头。用于捕捉（采集）图像和视频。\n帧率。现在的摄像头功能已非常强大，一般情况下，一秒钟可以采集 30 张以上的图像，一些好的摄像头甚至可以采集 100 张以上。我们把摄像头一秒钟采集图像的次数称为帧率。帧率越高，视频就越平滑流畅。然而，在直播系统中一般不会设置太高的帧率，因为帧率越高，占的网络带宽就越多。\n分辨率。摄像头除了可以设置帧率之外，还可以调整分辨率。我们常见的分辨率有 2K、1080P、720P、420P 等。分辨率越高图像就越清晰，但同时也带来一个问题，即占用的带宽也就越多。所以，在直播系统中，分辨率的高低与网络带宽有紧密的联系。也就是说，分辨率会跟据你的网络带宽进行动态调整。\n宽高比。分辨率一般分为两种宽高比，即 16:9 或 4:3。4:3 的宽高比是从黑白电视而来，而 16:9 的宽高比是从显示器而来。现在一般情况下都采用 16:9 的比例。\n麦克风。用于采集音频数据。它与视频一样，可以指定一秒内采样的次数，称为采样率。每个采样用几个 bit 表示，称为采样位深或采样大小。\n轨（Track）。WebRTC 中的“轨”借鉴了多媒体的概念。火车轨道的特性你应该非常清楚，两条轨永远不会相交。“轨”在多媒体中表达的就是每条轨数据都是独立的，不会与其他轨相交，如 MP4 中的音频轨、视频轨，它们在 MP4 文件中是被分别存储的。\n流（Stream）。可以理解为容器。在 WebRTC 中，“流”可以分为媒体流（MediaStream）和数据流（DataStream）。其中，媒体流可以存放 0 个或多个音频轨或视频轨；数据流可以存 0 个或多个数据轨。\n\n\n音视频采集API\nWebRTC提供了简单清晰的API来访问和采集本地音频设备或屏幕，具体使用如下\njsx//默认采集音频、视频\nconst constraints = &#123;\n    &#39;video&#39;: true,\n    &#39;audio&#39;: true\n&#125;\n//定制化采集参数\n    const constraints = &#123;\n        &#39;audio&#39;: &#123;&#39;echoCancellation&#39;: true&#125;,\n        &#39;video&#39;: &#123;\n            &#39;frameRate&#39;: 15, //帧率\n            &#39;width&#39;: &#123;&#39;min&#39;: 640&#125;, //采集视频最小宽度\n            &#39;height&#39;: &#123;&#39;min&#39;: 480&#125; //采集视频最小高度\n            &#125;\n        &#125;\n//采集用户音视频\nnavigator.mediaDevices.getUserMedia(constraints)\n    .then(stream =&gt; &#123;\n        console.log(&#39;Got MediaStream:&#39;, stream);\n    &#125;)\n    .catch(error =&gt; &#123;\n        console.error(&#39;Error accessing media devices.&#39;, error);\n    &#125;);\n//采集用户屏幕流\nnavigator.mediaDevices.getDisplayMedia(constraints)\n    .then(stream =&gt; &#123;\n        console.log(&#39;Got MediaStream:&#39;, stream);\n    &#125;)\n    .catch(error =&gt; &#123;\n        console.error(&#39;Error accessing media devices.&#39;, error);\n &#125;);\n\ngetUserMedia&#x2F;getDisplayMedia会触发一个浏览器对用户本地音视频设备的权限请求。\n\n若用户接受，则会根据constraints设置的video和audio配置，来采集对应的音频轨、视频轨。\n若用户拒绝，则会抛出NotAllowed异常，一旦没有发现可用的设备，则会抛出NotFoundError异常。\n\n\n具体API细节可参考如下链接\nMediaDevices - Web APIs | MDN\n\n\n\n\n\n\n信令交换在线状态、媒体信息、连接信息等，（通过部署信令服务器完成，后文会展开介绍）\n\n实现房间管理，加入房间、退出房间、发送其他消息等，方便客户端互相明确在线状态。\n\n交换媒体协商数据（音视频编码协议等）\n\n交换ICE「Interactive Connectivity Establishment」 Candidate，包含连接协议、IP、端口等\nICE Candidate （ICE 候选者）。它表示 WebRTC 与远端通信时使用的协议、IP 地址和端口，一般由以下字段组成：本地 IP 地址本地端口号候选者类型，包括 host、srflx 和 relay优先级传输协议访问服务的用户名……\nbash&#123;\n  IP: xxx.xxx.xxx.xxx,\n  port: number,\n  type: host/srflx/relay,\n  priority: number,\n  protocol: UDP/TCP,\n  usernameFragment: string\n  ...\n&#125;\n\n点对点连接通信的双方都需要新建一个RTCPeerConnection对象，实现点对点的P2P连接。RTCPeerConnection对象主要实现以下功能：\n\n承载本地及远端音视频等数据流，通过点对点或者中继的形式发送数据，同时绑定了相应的回调函数，当有远端的数据流到来时，提醒业务层进行后续渲染操作\n\n自动获取媒体描述信息SDP，同时存储通过信令服务器交换获取到的远端SDP信息。\n\n收集ICE（Interactive Connectivity Establishment） Candidate。同时存储通过信令服务器交换获取到的远端 ICE Candidate信息，以便进行端与端之间的连接\n\nhost 类型，即本机内网的 IP 和端口；最容易手机的Candidate\nsrflx 类型, 通过STUN协议实现，即本机 NAT 映射后的外网的 IP 和端口；通过在外网搭建一个 STUN 服务器，通过发数据包的方式获取自己外网IP和端口\nrelay 类型，即中继服务器的 IP 和端口；通过向 TURN 服务器发送 Allocation 指令，relay 服务就会在服务器端分配一个新的 relay 端口，用于两端中转 UDP 数据报。\n\n\n\n\nNAT穿越建立连接，WebRTC底层都帮我们实现了，这里不展开介绍了，有兴趣的小伙伴可以参考以下文档\nWebRTC音视频传输基础：NAT穿透\n\n\n数据中转点对点连接失败的数据中转（通过TURN服务器实现）\n\n在P2P连接失败时，提供数据中继服务时\n在ICE交换的过程中，协助客户端获取自己的外网IP和端口\n\n以上就是我们远程通信的关键步骤，下图就是这个完整的流程呈现。图片来源于极客时间李超老师的课程《从0打造音视频直播系统》\n\n上图是整个 WebRTC 1 对 1 音视频实时通话的过程图。通过这幅图，你可以看出要实现 1 对 1 音视频实时通话其过程还是蛮复杂的。\n这幅图从大的方面可以分为 4 部分，即两个 WebRTC 终端（上图中的两个大方框）、一个 Signal（信令）服务器和一个 STUN&#x2F;TURN 服务器。\nWebRTC 终端，负责音视频采集、编解码、NAT 穿越、音视频数据传输。\nSignal 服务器，负责信令处理，如加入房间、离开房间、媒体协商消息的传递等。\nSTUN&#x2F;TURN 服务器，负责获取 WebRTC 终端在公网的 IP 地址，以及 NAT 穿越失败后的数据中转。\n接下来我们依据上边的整体流程及理论指导，来进行具体的实现环节~\n具体实现前置准备\n2M带宽以上的云主机+域名+https证书\n不管是搭建信令和中继服务器、还是提供客户端在浏览器访问同一套通信代码，都需要一台云主机。\n为何需要 2M 以上带宽的带宽呢？，对于一路 720P 的视频，一般情况下需要 1.2M 的带宽，因此在两人通信时，如果都走服务器中转的话就需要 2.4M 的带宽了。所以为了保证双方通信顺畅，带宽是必须要能跟得上的。\n因为浏览器安全限制，访问音视频时，都需要相应的https证书，所以域名和https证书都是需要准备的。\n\n\n\n服务器环境部署\nweb服务器搭建\n\n主要是给客户端(浏览器)提供执行的文件(html、css、js)，我们示例中用Node.js来实现，主要是考虑到后续信令服务依赖于Node.js。下边是代码示例，我们暂命名为server.js\njavascriptvar https = require(&#39;https&#39;);\nvar express = require(&#39;express&#39;);\nvar serveIndex = require(&#39;serve-index&#39;);\n...\n//使用express实现WEB服务\nvar app = express(); \napp.use(serveIndex(&#39;./public&#39;));\napp.use(express.static(&#39;./public&#39;));\n\n//HTTPS 证书和密钥文件\nvar options = &#123;\n  key : fs.readFileSync(&#39;./cert/yourrtc.cn.key&#39;),\n  cert: fs.readFileSync(&#39;./cert/yourrtc.cn.pem&#39;)\n&#125;\n\n//https server\nvar https_server = https.createServer(options, app);\nvar io = socketIo.listen(https_server);\nhttps_server.listen(443, &#39;0.0.0.0&#39;);\n...​\n\n\n\n信令服务搭建\n\n我们同样使用Node.js来搭建信令服务器，代码可以放在上述的server.js中，只需添加socket的服务端部分即可\njavascriptconst static = require(&#39;node-static&#39;);\nconst http = require(&#39;http&#39;);\nconst file = new(static.Server)();\nconst app = http.createServer(function (req, res) &#123;\n  file.serve(req, res);\n&#125;).listen(2013);\n\nconst io = require(&#39;socket.io&#39;).listen(app); //侦听 2013\n\nio.sockets.on(&#39;connection&#39;, (socket) =&gt; &#123;\n\n  // convenience function to log server messages to the client\n  function log()&#123; \n    const array = [&#39;&gt;&gt;&gt; Message from server: &#39;]; \n    for (var i = 0; i &lt; arguments.length; i++) &#123;\n      array.push(arguments[i]);\n    &#125; \n      socket.emit(&#39;log&#39;, array);\n  &#125;\n\n  socket.on(&#39;message&#39;, (message) =&gt; &#123; //收到message时，进行广播\n    log(&#39;Got message:&#39;, message);\n    // for a real app, would be room only (not broadcast)\n    socket.broadcast.emit(&#39;message&#39;, message); //在真实的应用中，应该只在房间内广播\n  &#125;);\n\n  socket.on(&#39;create or join&#39;, (room) =&gt; &#123; //收到 “create or join” 消息\n\n  var clientsInRoom = io.sockets.adapter.rooms[room];\n    var numClients = clientsInRoom ? Object.keys(clientsInRoom.sockets).length : 0; //房间里的人数\n\n    log(&#39;Room &#39; + room + &#39; has &#39; + numClients + &#39; client(s)&#39;);\n    log(&#39;Request to create or join room &#39; + room);\n\n    if (numClients === 0)&#123; //如果房间里没人\n      socket.join(room);\n      socket.emit(&#39;created&#39;, room); //发送 &quot;created&quot; 消息\n    &#125; else if (numClients === 1) &#123; //如果房间里有一个人\n    io.sockets.in(room).emit(&#39;join&#39;, room);\n      socket.join(room);\n      socket.emit(&#39;joined&#39;, room); //发送 “joined”消息\n    &#125; else &#123; // max two clients\n      socket.emit(&#39;full&#39;, room); //发送 &quot;full&quot; 消息\n    &#125;\n    socket.emit(&#39;emit(): client &#39; + socket.id +\n      &#39; joined room &#39; + room);\n    socket.broadcast.emit(&#39;broadcast(): client &#39; + socket.id +\n      &#39; joined room &#39; + room);\n\n  &#125;);\n\n&#125;);\n\n\nturn服务器搭建\n\nturn服务器主要是用来在点对点连接失败的时候，进行数据中继转发的。同时也可用于帮助客户端获取自己的外网IP地址和端口，协助客户端建立点对点的连接。\n我们采用目前最著名的Turn服务器，由Google 发起的开源项目coturn，地址为coturn，\n安装coturn\n从 https://github.com/coturn/coturn 下载 coturn 代码；\n执行 .&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;coturn 生成 Makefile；\n执行 make 来编译 coturn；\n执行 sudo make install 进行安装。\n\n\n配置coturn\n编辑coturn的配置文件\nshellvi /etc/coturn/turnserver.conf\n修改以下四项配置即可\nshelluser=use:pas #连接turn服务器的用户名和密码\nrealm=yourrtc.cn #设置为你的访问域名\nlistening-port=3478 #监听端口，固定为3478\nexternal-ip=1.2.3.55 #更换为你的公网IP​\n\n\n\n\n\n\n客户端代码编写部署\n客户端使用信令服务,建立client.js文件\n\njavascriptvar isInitiator;\n\nroom = prompt(&#39;Enter room name:&#39;); //弹出一个输入窗口\n\nconst socket = io.connect(); //与服务端建立socket连接\n\nif (room !== &#39;&#39;) &#123; //如果房间不空，则发送 &quot;create or join&quot; 消息\n  console.log(&#39;Joining room &#39; + room);\n  socket.emit(&#39;create or join&#39;, room);\n&#125;\n\n//socket的message消息是主要的交换渠道，交换双方的媒体信息及连接信息\nsocket.on(&#39;message&#39;, (roomid, data) =&gt; &#123;\n    console.log(&#39;receive message!&#39;, roomid, data);\n\n    if(data === null || data === undefined)&#123;\n        console.error(&#39;the message is invalid!&#39;);\n        return;\t\n    &#125;\n\n    if(data.hasOwnProperty(&#39;type&#39;) &amp;&amp; data.type === &#39;offer&#39;) &#123;\n        \n        offer.value = data.sdp;\n\n        pc.setRemoteDescription(new RTCSessionDescription(data));\n\n        //create answer\n        pc.createAnswer()\n            .then(getAnswer)\n            .catch(handleAnswerError);\n\n    &#125;else if(data.hasOwnProperty(&#39;type&#39;) &amp;&amp; data.type == &#39;answer&#39;)&#123;\n        answer.value = data.sdp;\n        pc.setRemoteDescription(new RTCSessionDescription(data));\n    \n    &#125;else if (data.hasOwnProperty(&#39;type&#39;) &amp;&amp; data.type === &#39;candidate&#39;)&#123;\n        var candidate = new RTCIceCandidate(&#123;\n            sdpMLineIndex: data.label,\n            candidate: data.candidate\n        &#125;);\n        pc.addIceCandidate(candidate);\t\n    \n    &#125;else&#123;\n        console.log(&#39;the message is invalid!&#39;, data);\n    \n    &#125;\n\n&#125;)\nsocket.on(&#39;join&#39;, (room) =&gt; &#123; //如果从服务端收到 “join&quot; 消息\n  console.log(&#39;Making request to join room &#39; + room);\n  console.log(&#39;You are the initiator!&#39;);\n  //根据信令服务的通知来建立相应的连接及绑定流，后续有示例\n  createPeerConnection(); //加入房间成功后，开始建立PeerConnection对象\n  bindTracks(); //绑定相应的流\n\n&#125;);\n\nsocket.on(&#39;log&#39;, (array) =&gt; &#123;\n  console.log.apply(console, array);\n&#125;);\n//定义客户端发送socket消息的方法\nfunction sendMessage(roomid, data)&#123;\n\n    console.log(&#39;send message to other end&#39;, roomid, data);\n    if(!socket)&#123;\n        console.log(&#39;socket is null&#39;);\n    &#125;\n    socket.emit(&#39;message&#39;, roomid, data);\n&#125;\n//填写本地的媒体信息，并通过信令服务发送到远端，适合当前客户端为初始发起者。\nfunction getOffer(desc)&#123;\n    pc.setLocalDescription(desc);\n    offer.value = desc.sdp;\n    offerdesc = desc;\n    //send offer sdp\n    sendMessage(roomid, offerdesc);\t\n&#125;\n\n//收到远端的媒体信息时，建立本客户端应答的媒体信息，并发送到远端，适合当前客户端为应答者\nfunction getAnswer(desc)&#123;\n    pc.setLocalDescription(desc);\n    answer.value = desc.sdp;\n    //send answer sdp\n    sendMessage(roomid, desc);\n&#125;\n客户端结合turn服务器，进行点对点的连接与流的传输，也在client.js编写\n\njavascript//定义turn服务器的基础配置，与上文中coturn服务器的配置一致即可。\nvar pcConfig = &#123;\n  &#39;iceServers&#39;: [&#123; //指定 ICE 服务器信令\n    &#39;urls&#39;: &#39;turn:stun.al.learningrtc.cn:3478&#39;, //turn服务器地址，需要加`turn:`的固定前缀\n    &#39;credential&#39;: &quot;passwd&quot;, //turn服务器密码，你要用自己的 \n    &#39;username&#39;: &quot;username&quot;  //turn服务器用户名，你要用自己的\n  &#125;]\n&#125;;\n\n//建立RTCPeerConnection对象，注册收到数据流的回调事件\nfunction createPeerConnection()&#123;\n \n  if(!pc)&#123;\n    pc = new RTCPeerConnection(pcConfig); //创建peerconnection对象\n    ...\n    pc.ontrack = getRemoteStream; //当远端的track到来时会触发该事件\n  &#125;else &#123;\n    console.log(&#39;the pc have be created!&#39;);\n  &#125;\n\n  return;\n&#125;\n\n//当远程音视频流数据传输完成的时候，进行渲染播放操作\nvar remoteVideo = document.querySelector(&#39;video#remotevideo&#39;);\nfunction getRemoteStream(e)&#123;  //事件处理函数\n  remoteStream = e.streams[0]; //保存远端的流\n  remoteVideo.srcObject = e.streams[0]; //与HTML中的视频标签绑定\n&#125;\n\n\n//把本地的媒体流添加到RTCPeerConnection对象里边，供后续远程传输\nfunction bindTracks()&#123;\n  //add all track into peer connection\n  localStream.getTracks().forEach((track)=&gt;&#123;\n    pc.addTrack(track, localStream); //将track与peerconnection绑定\n  &#125;);\n&#125;\n再添加一些静态代码，方便渲染和预览本地及远端的音视频\n\nhtml&lt;div&gt;\n    &lt;button id=&quot;connserver&quot;&gt;Connect Sig Server&lt;/button&gt;\n    &lt;button id=&quot;start&quot; disabled&gt;Start&lt;/button&gt;\t\n    &lt;button id=&quot;call&quot; disabled&gt;Call&lt;/button&gt;\t\n    &lt;button id=&quot;hangup&quot; disabled&gt;HangUp&lt;/button&gt;\t\n    &lt;button id=&quot;leave&quot; disabled&gt;Leave&lt;/button&gt;\t\n&lt;/div&gt;\n\n\n&lt;div&gt;\n    &lt;input id=&quot;shareDesk&quot; type=&quot;checkbox&quot;/&gt;&lt;label for=&quot;shareDesk&quot;&gt;Share Desktop&lt;/label&gt;\n&lt;/div&gt;\n&lt;div id=&quot;preview&quot;&gt;\n    &lt;div width=&quot;40%&quot;&gt;\n        &lt;h2&gt;Local:&lt;/h2&gt;\n        &lt;video id=&quot;localvideo&quot; autoplay playsinline muted&gt;&lt;/video&gt;\n        &lt;h2&gt;Offer SDP:&lt;/h2&gt;\n        &lt;textarea id=&quot;offer&quot; style=&quot;display: none;&quot;&gt;&lt;/textarea&gt;\n    &lt;/div&gt;\n    &lt;div width=&quot;40%&quot;&gt;\n        &lt;h2&gt;Remote:&lt;/h2&gt;\n        &lt;video id=&quot;remotevideo&quot; autoplay playsinline&gt;&lt;/video&gt;\n        &lt;h2&gt;Answer SDP:&lt;/h2&gt;\n        &lt;textarea id=&quot;answer&quot; style=&quot;display: none;&quot;&gt;&lt;/textarea&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;h2&gt;Chat:&lt;/h2&gt;\n        &lt;textarea id=&quot;chat&quot; disabled&gt;&lt;/textarea&gt;\n        &lt;textarea id=&quot;sendtxt&quot; disabled&gt;&lt;/textarea&gt;\n        &lt;button id=&quot;send&quot; disabled&gt;Send&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;总结以上就是浏览器端实现 1 对 1 实时通话的整体逻辑。在本文中，我们引入了WebRTC这项技术，并逐步拆解了通信的基本步骤和要素，最后再把整体的运行环境和通信模块展开介绍。\n不得不说，涉及到的技术和术语知识还是很多的，鉴于能力和篇幅有限，此篇文章无法深入到众多的知识点，比如NAT穿越等。如果你对音视频通信感兴趣的话，希望这篇博客能帮助你理清思路，帮你入门。\n参考资料极客时间-李超老师-从 0 打造音视频直播系统\nGetting started with WebRTC\nWebRTC进阶\nWebRTC-demo\n","slug":"WebRTC","date":"2024-04-16T10:09:03.000Z","categories_index":"","tags_index":"","author_index":"Feng"},{"id":"a0870e85994130b27751635f41a5a534","title":"Hammerspoon  一款Mac上提升你工作学习效率的神器","content":"什么是Hammerspoon？Hammerspoon是一款针对macOS的自动化工具。其核心与本质是在lua脚本引擎与操作系统之间的桥梁和通道，赋予用户极大的能力和自由度去调用系统功能，最大化地发挥系统功能，提升我们的学习和工作效率。\n至于lua的语法，对于稍微有编程基础的同学来说都很好理解。以下是一个lua的快速学习参考链接，可以参考，在此就不展开介绍了。\n\nLua语言快速入门\n\nHammerspoon可以帮我做什么？顾名思义，Hammerspoon翻译过来为锤子勺子，既能帮你干一些体力活，也能辅助你完成一些日常精细的工作。\n你可以编写简单的lua代码与macOS系统进行充分交互。控制和操作MacOS系统的应用软件、窗口、输入法、鼠标、文件系统、声音设备、屏幕、剪贴板、wifi等等。\n我来依照我自身的日常使用场景来举几个例子。\n\n一键唤起各个特定应用\n   我们工作或学习时可能经常会打开多个软件，并在这几个应软件进行频繁切换。当然，Mac下用触摸板或者Cmd+Tab可以实现方便切换。打开2-3个软件时原生的方法可能会很方便，但如果你打开5个应用以上时，你部分时间可能就得消耗在一直分辨、挑选真正想打开的软件。\n  而使用Hammerspoon你可以定义一系列的快捷键，来轻松唤起特定的应用，实现即想即达。\n  比如我用 Cmd+Ctrl+w 可以轻松唤出微信，Cmd+Ctrl+c打开Chrome，Cmd+Ctrl+d打开钉钉，Cmd+Ctrl+t打开终端iTerm2等等。\n\n多软件下的输入法个性化配置\n  一般我们会打开微信、钉钉用中文进行消息发送，但切换到终端时我们需要用英文进行命令行或者编程。Hammerspoon可以支持我们对特定的应用进行对应输入法的配置。比如我配置微信、钉钉无论何时打开都是中文，同时终端一般默认用英文输入法。\n\n多屏下窗口快速移动和鼠标焦点切换及窗口布局\n\n鼠标焦点和光标切换\n在编程或者查看资料的时候，需要经常在多个屏幕中切换。所以我借助Hammerspoon配置了多个屏幕下切换光标焦点的快捷键。\n\n\n软件窗口在多个屏幕间快速移动\n在演示功能用例或者预览资料的时候，大屏预览会比较舒服和方便。快捷键可实现快速移动，并且自动最大化，无需你重新调整窗口布局。\n\n\n同屏幕多软件窗口布局。\n支持同屏幕打开多个窗口，并进行各种比例的布局。常见的是左右布局及上下布局。\n\n\n\n\n自定义快捷键，查看当前天气、公历农历时间。\n\n有时候我们在沉浸式地全屏时，想看天气或者很多资料，Hammerspoon支持我们调用系统展示层，进行相应的信息展示，非常方便。如下所示。\n\n  \n\n\n如何安装Hammerspoon？点击Hammerspoon下载，解压之后，直接拖到应用软件目录下即可完成安装。\n如何配置及应用Hammerspoon？\n新建Hammerspoon配置目录\n  Hammerspoon需要在如下目录下自定义创建配置文件 ~/.hammerspoon/init.lua ，如果没有.hammerspoon目录，则需要新建。\n\n\n目录结构介绍\n~/.hammerspoon —— 配置文件主目录\n\ninit.lua —— 配置总入口，加载相关配置文件\nmodules —— 各模块目录\nhotkey.lua  —— 组合快捷键定义\ninputsources.lua —— 应用软件输入法实现\nwindows.lua —— 窗口布局、移动、聚焦等实现\n\n\n\n安装及基本配置目录创建完成后，就可以进行编写代码实现你的个性化需求了。\n\n各配置文件配置\n首先是入口文件init.lua，可参照如下配置。入口文件中引用其他配置文件，同时我配置了重新加载配置的功能，方便修改配置文件后即时生效。\n\n\n\n-- Reload config automatically\nlocal configFileWatcher\nfunction reloadConfig()\n  configFileWatcher:stop()\n  configFileWatcher = nil\n  hs.reload()\nend\n\nconfigFileWatcher = hs.pathwatcher.new(os.getenv(&quot;HOME&quot;) .. &quot;/.hammerspoon/&quot;, reloadConfig)\nconfigFileWatcher:start()\n\n-- Load local modules\nrequire &quot;modules/hotkey&quot; -- hotkey.lua\nrequire &quot;modules/windows&quot; -- windows.lua\nrequire &quot;modules/inputsource&quot; -- inputsource.lua\n\n-- Load Spoons\n--\n\n-- Finally, show a notification that we finished loading the config\nhs.notify.new( &#123;title=&#39;Hammerspoon&#39;, subTitle=&#39;Configuration loaded&#39;&#125; ):send()\n\n- 组合快捷键定义modules目录下的hotkey.lua\n\nhyper = &#123;&quot;cmd&quot;, &quot;ctrl&quot;, &quot;alt&quot;&#125;\nhyperShift = &#123;&quot;alt&quot;, &quot;shift&quot;&#125;\nhyperCtrl = &#123;&quot;alt&quot;, &quot;ctrl&quot;&#125;\nhyperAlt = &#123;&quot;ctrl&quot;, &quot;alt&quot;, &quot;shift&quot;&#125;\n\n- 然后是modules目录下的inputsource.lua文件，为各应用设置对应的输入法\n\nlocal application = require &quot;hs.application&quot;\nlocal hotkey = require &quot;hs.hotkey&quot;\nlocal window = require &quot;hs.window&quot;\nlocal alert = require &quot;hs.alert&quot;\nlocal keycodes = require &quot;hs.keycodes&quot;\nlocal function Chinese()\n    -- 简体拼音\n    keycodes.currentSourceID(&quot;com.sogou.inputmethod.sogou.pinyin&quot;)\nend\n\nlocal function English()\n    -- ABC\n    keycodes.currentSourceID(&quot;com.apple.keylayout.ABC&quot;)\nend\n\n-- app to expected ime config\n-- app和对应的输入法\nlocal app2Ime = &#123;\n    &#123;&#39;/Applications/iTerm.app&#39;, &#39;English&#39;&#125;,\n    &#123;&#39;/System/Library/CoreServices/Finder.app&#39;, &#39;English&#39;&#125;,\n    &#123;&#39;/Applications/System Preferences.app&#39;, &#39;English&#39;&#125;,\n    &#123;&#39;/Applications/DingTalk.app&#39;, &#39;Chinese&#39;&#125;,\n    &#123;&#39;/Applications/WeChat.app&#39;, &#39;Chinese&#39;&#125;,\n    &#123;&#39;/Applications/Notion.app&#39;, &#39;Chinese&#39;&#125;,\n    -- &#123;&#39;/Applications/Google Chrome.app&#39;, &#39;English&#39;&#125;,\n    -- &#123;&#39;/Applications/Kindle.app&#39;, &#39;English&#39;&#125;,\n    -- &#123;&#39;/Applications/Visual Studio Code.app&#39;, &#39;English&#39;&#125;,\n    -- &#123;&#39;/Applications/Xcode.app&#39;, &#39;English&#39;&#125;,\n&#125;\n\nfunction updateFocusAppInputMethod()\n    local ime = &#39;English&#39;\n    local focusAppPath = window.frontmostWindow():application():path()\n    -- alert.show(&quot;path:  &quot;..focusAppPath )\n    for index, app in pairs(app2Ime) do\n        -- alert.show(&quot;app:  &quot;..app[1])\n        -- alert.show(&quot;im:  &quot;..app[2])\n        local appPath = app[1]\n        local expectedIme = app[2]\n\n        if focusAppPath == appPath then\n            ime = expectedIme\n            break\n        end\n    end\n\n    if ime == &#39;English&#39; then\n        English()\n    else\n        Chinese()\n    end\nend\n\n-- helper hotkey to figure out the app path and name of current focused window\n-- 当选中某窗口按下ctrl+command+m时会显示应用的路径等信息\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;m&quot;, function()\n    alert.show(&quot;App path is:        &quot;\n    ..window.focusedWindow():application():path()\n    ..&quot;\\n&quot;\n    ..&quot;App name:      &quot;\n    ..window.focusedWindow():application():name()\n    ..&quot;\\n&quot;\n    ..&quot;IM source id:  &quot;\n    ..keycodes.currentSourceID())\nend)\n\n-- Handle cursor focus and application&#39;s screen manage.\n-- 窗口激活时自动切换输入法\nfunction applicationWatcher(appName, eventType, appObject)\n    if (eventType == application.watcher.activated or eventType == application.watcher.launched) then\n        updateFocusAppInputMethod()\n    end\nend\n\nappWatcher = application.watcher.new(applicationWatcher)\nappWatcher:start()\n\n   - 最后是modules目录下的windows.lua文件，进行窗口、屏幕、鼠标的控制。\n\n-- window management\nlocal application = require &quot;hs.application&quot;\nlocal hotkey = require &quot;hs.hotkey&quot;\nlocal window = require &quot;hs.window&quot;\nlocal layout = require &quot;hs.layout&quot;\nlocal grid = require &quot;hs.grid&quot;\nlocal hints = require &quot;hs.hints&quot;\nlocal screen = require &quot;hs.screen&quot;\nlocal alert = require &quot;hs.alert&quot;\nlocal fnutils = require &quot;hs.fnutils&quot;\nlocal geometry = require &quot;hs.geometry&quot;\nlocal mouse = require &quot;hs.mouse&quot;\n\n-- default 0.2\nwindow.animationDuration = 0\n-- alert.defaultStyle[&#39;fadeOutDuration&#39;] = 0.05\n\nfunction toggle_full()\n    local win = window.focusedWindow()\n    if win:isFullScreen() then\n        win:toggleFullScreen()\n    end\nend\n-- left half\nhotkey.bind(hyperCtrl, &quot;h&quot;, function()\n  if window.focusedWindow() then\n    window.focusedWindow():moveToUnit(layout.left50)\n  else\n    alert.show(&quot;No active window&quot;)\n  end\nend)\n\n-- right half\nhotkey.bind(hyperCtrl, &quot;l&quot;, function()\n  toggle_full()\n  window.focusedWindow():moveToUnit(layout.right50)\nend)\n\n-- top half\nhotkey.bind(hyperCtrl, &quot;k&quot;, function()\n  toggle_full()\n  window.focusedWindow():moveToUnit&#39;[0,0,100,50]&#39;\nend)\n\n-- bottom half\nhotkey.bind(hyperCtrl, &quot;j&quot;, function()\n  toggle_full()\n  window.focusedWindow():moveToUnit&#39;[0,50,100,100]&#39;\nend)\n\n-- full screen\nhotkey.bind(hyperCtrl, &#39;;&#39;, function() \n  window.focusedWindow():toggleFullScreen()\nend)\n\n-- center window\nhotkey.bind(hyperCtrl, &#39;c&#39;, function() \n  toggle_full()\n  window.focusedWindow():centerOnScreen()\nend)\n\n-- maximize window\nhotkey.bind(hyperCtrl, &#39;m&#39;, function()\n  toggle_full()\n  toggle_maximize()\nend)\n\n-- defines for window maximize toggler\nlocal frameCache = &#123;&#125;\n-- toggle a window between its normal size, and being maximized\nfunction toggle_maximize()\n    local win = window.focusedWindow()\n    win:maximize()\nend\n\n-- move active window to previous monitor\nhotkey.bind(hyper, &quot;h&quot;, function()\n  window.focusedWindow():moveOneScreenWest()\nend)\n\n-- move active window to next monitor\nhotkey.bind(hyper, &quot;l&quot;, function()\n  window.focusedWindow():moveOneScreenEast()\nend)\n\n-- open application using shortcut\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;c&quot;, function()\n  application.open(&#39;Google Chrome.app&#39;)\nend)\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;e&quot;, function()\n  application.open(&#39;Microsoft Edge.app&#39;)\nend)\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;t&quot;, function()\n  application.open(&#39;iTerm.app&#39;)\nend)\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;w&quot;, function()\n  application.open(&#39;WeChat.app&#39;)\nend)\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;d&quot;, function()\n  application.open(&#39;DingTalk.app&#39;)\nend)\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;n&quot;, function()\n  application.open(&#39;Notion.app&#39;)\nend)\n-- open Desktop Folder\nhotkey.bind(&#123;&#39;ctrl&#39;, &#39;cmd&#39;&#125;, &quot;f&quot;, function()\n  hs.execute(&#39;open /Users/Feng/Desktop/&#39;, true);\nend)\n\n--Predicate that checks if a window belongs to a screen\nfunction isInScreen(screen, win)\n  return win:screen() == screen\nend\n\nfunction focusScreen(screen)\n  --Get windows within screen, ordered from front to back.\n  --If no windows exist, bring focus to desktop. Otherwise, set focus on\n  --front-most application window.\n  local windows = fnutils.filter(\n      window.orderedWindows(),\n      fnutils.partial(isInScreen, screen))\n  local windowToFocus = #windows &gt; 0 and windows[1] or window.desktop()\n  windowToFocus:focus()\n\n  -- move cursor to center of screen\n  local pt = geometry.rectMidPoint(screen:fullFrame())\n  mouse.setAbsolutePosition(pt)\nend\n\n-- maximized active window and move to selected monitor\nlocal moveto = function(win, n)\n  local screens = screen.allScreens()\n  if n &gt; #screens then\n    alert.show(&quot;Only &quot; .. #screens .. &quot; monitors &quot;)\n  else\n    local toWin = screen.allScreens()[n]:name()\n    -- alert.show(&quot;Move &quot; .. win:application():name() .. &quot; to &quot; .. toWin)\n    layout.apply(&#123;&#123;nil, win:title(), toWin, layout.maximized, nil, nil&#125;&#125;)\n    -- window.focusedWindow():toggleFullScreen()\n  end end\n\n//move cursor in different screens\nhotkey.bind(hyperShift, &quot;1&quot;, function()\n  -- local win = window.focusedWindow()\n  -- moveto(win, 1)\n  focusScreen(screen.allScreens()[1])\n  alert.show(&quot;Mac-1&quot;, 1)\n  -- alert.show(&quot;Cursor is on the &quot; .. screen.allScreens()[1]:fullFrame().. &quot; monitors &quot;)\n\nend)\n\nhotkey.bind(hyperShift, &quot;2&quot;, function()\n  focusScreen(screen.allScreens()[3])\n  alert.show(&quot;Redmi-2&quot;, 1)\nend)\n\nhotkey.bind(hyperShift, &quot;3&quot;, function()\n  focusScreen(screen.allScreens()[2])\n  alert.show(&quot;Dell-3&quot;, 1)\nend)\n\n总结以上就是Hammerspoon的整体介绍了，希望看到这篇文章的你能有收获~\n","slug":"article-title","date":"2023-07-28T07:09:03.000Z","categories_index":"","tags_index":"","author_index":"Feng"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-07-28T03:59:37.942Z","categories_index":"","tags_index":"","author_index":"Feng"}]