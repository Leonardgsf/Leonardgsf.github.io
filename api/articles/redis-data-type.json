{"title":"多图预警-帮你读懂Redis的主流数据结构","uid":"7f918dfe9b39aefbe3b584c8cf1d2798","slug":"redis-data-type","date":"2024-09-26T12:07:27.000Z","updated":"2024-09-26T12:43:20.620Z","comments":true,"path":"api/articles/redis-data-type.json","keywords":null,"cover":[],"content":"<ul>\n<li><p>开篇</p>\n<ul>\n<li><p>你有想过，当你往Redis中写入一个键值对，或者读取一个键值对的时候，数据在Redis中是如何存储及寻址的么？</p>\n</li>\n<li><p>如果你还不清楚或者有兴趣了解，请带着问题往下阅读，相信这篇文章会帮你梳理一下思路。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>全局哈希表</p>\n<ul>\n<li>哈希表介绍<ul>\n<li>哈希表是由数组扩展而来，利用了数组支持按照下标随机访问的特性。</li>\n<li>当你要在Reids中设置一个键值对的时候，比如<code>set testkey hello_world</code> . Redis通过预设的哈希函数把的键映射为下标，此时为testkey，然后将数据存储在数组中对应下标的位置。比如下图中的5号位置。</li>\n<li>当我们按照键来查询元素值时，我们用同样的哈希函数，将键转化为数组下标5，从对应的数组下标的位置取出我们存储数据。</li>\n</ul>\n</li>\n<li>Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项包含0个多个<code>entry</code>，entry就是一个称为dictEntry的结构体，用来指向一个键值对的值的位置。<code>注意：</code>新来的同学，这里的entry里保存的不是上述的具体值，即<code>键-testkey和值-hello_world，</code>而是保存的存储这两个具体值的地址。如下图：<em>key</em>和<em>value</em>是指针，存储的是地址。</li>\n</ul>\n<p>  <img src=\"/img/redis/image_0.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>dictEntry </p>\n<ul>\n<li><code>dictEntry</code>结构中有三个 8 字节的指针，分别指向 key对应的<code>RedisObject</code>对象、value 对应的<code>RedisObject</code>对象以及下一个 <code>dictEntry</code>。那RedisObject是何方神圣呢？且往后看：</li>\n</ul>\n<p>  <img src=\"/img/redis/image_1.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>RedisObject </p>\n<ul>\n<li><code>dictEntry</code>中有指向key和value的指针，这个指针就是指向各自对应的<code>RedisObject</code>。所以可以说Redis键值对中的key和value的具体值的访问都是从<code>RedisObject</code>开始的。以下是<code>RedisObject</code>的具体结构</li>\n</ul>\n<p>  <img src=\"/img/redis/image_2.png\" alt=\"image.png\"></p>\n</li>\n<li><p>Reids中键的数据类型统一为String，也是基于RedisObject来保存。为了节省内存空间，Redis 还对 Long 类型整数和 <code>SDS</code> （Simple Dynamic String - 简单动态字符串）的内存布局做了专门的设计。</p>\n<ul>\n<li>当保存的是 <code>Long</code> 类型整数时，<code>RedisObject</code> 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li>\n<li>当保存的是字符串数据，并且字符串小于等于 44 字节时，<code>RedisObject</code> 中的元数据、指针和 <code>SDS</code> 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 <code>embstr</code> 编码方式。</li>\n<li>当字符串大于 44 字节时，<code>SDS</code> 的数据量就开始变多了，Redis 就不再把 <code>SDS</code> 和 <code>RedisObject</code> 布局在一起了，而是会给 <code>SDS</code> 分配独立的空间，并用指针指向 <code>SDS</code> 结构。这种布局方式被称为 raw 编码模式。</li>\n</ul>\n<p>  <img src=\"/img/redis/image_3.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n\n<ul>\n<li><p>众所周知，Redis的键值对中的值除了字符串，还包含一些复杂的集合类型，比如链表、哈希等。</p>\n<ul>\n<li>这些复杂类型的地址都是用<code>*ptr</code>来寻址的。以下为不同的值的数据类型对应的具体的底层实现：</li>\n</ul>\n<p>  <img src=\"/img/redis/image_4.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>当值的数据类型为<code>String</code>时，与键的底层实现一致。（这里再贴一下示意图，大家就不用再往回翻了~）</p>\n<p>  <img src=\"/img/redis/image_3.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>当值的数据类型为<code>hash/list/sorted set</code>，底层实现为压缩列表时</p>\n<ul>\n<li><code>*ptr</code>指向底层的<strong>压缩列表的起始地址</strong>（即压缩列表的头部）。</li>\n<li>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。</li>\n<li>每个 <code>entry</code> 的元数据包括下面几部分。<ul>\n<li><code>prev_len</code>，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。</li>\n<li><code>len</code>：表示自身长度，4 字节；</li>\n<li><code>encoding</code>：表示编码方式，1 字节；</li>\n<li><code>content</code>：保存实际数据。</li>\n</ul>\n</li>\n<li>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</li>\n</ul>\n<p>  <img src=\"/img/redis/image_5.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n\n<ul>\n<li><p>当值的数据类型为<code>hash/set</code>，且底层实现为<code>hash</code>表时:</p>\n<ul>\n<li><code>ptr</code> 会直接指向哈希表结构的起始位置。通过这个指针，Redis 可以访问和操作哈希表中的数据。如下所示：</li>\n</ul>\n<p>  <img src=\"/img/redis/image_6.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>当 Redis 中的值的类型是 **<code>set</code>**，且底层实现为 <strong>整数集合（<code>intset</code>）</strong> 时:</p>\n<ul>\n<li><code>redisObject</code> 结构体的 <code>*ptr</code> 指针指向整数集合的起始地址。整数集合是一个紧凑的、无序的数据结构，专门用来存储整数，并且可以自动调整存储整数的大小以节省空间。在这里指向的就是<code>a[0]</code>的起始地址<code>1000</code></li>\n</ul>\n<p>  <img src=\"/img/redis/image_7.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>当值的类型为<code>sorted set</code>，且底层实现为跳表时，<code>ptr</code> 指针指向一个包含两部分的结构体：</p>\n<ol>\n<li><strong>跳表（<code>skiplist</code>）</strong>：负责按分数顺序存储所有元素。</li>\n<li><strong>字典（<code>dict</code>）</strong>：负责存储成员到分数的映射，以支持 <code>O(1)</code> 时间复杂度的分数查找和存在性检查。</li>\n</ol>\n<p>  <img src=\"/img/redis/image_8.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li><p>当值的类型为list，且底层实现为双向链表时:</p>\n<ul>\n<li><code>ptr</code> 指针指向list 类型的 <code>redisObject</code> ，<code>*ptr</code> 指针指向链表的头部节点。这个头部节点包含指向第一个实际数据节点的链接，以及链表的长度和尾部节点的链接。这样的结构设计允许从列表的任一端快速添加或删除元素，提高操作的效率。</li>\n</ul>\n<p>  <img src=\"/img/redis/image_9.png\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p></p>\n\n<ul>\n<li>总结<ol>\n<li>我们从Redis的起始全局哈希表开始，明白Redis是怎么组合及保存所有键值对的</li>\n<li>从具体的全局哈希表中的每一个<code>DictEntry</code>开始，剖析内部组成，重点关注指向<code>key</code>和<code>value</code>的两个指针</li>\n<li>然后我们开始关注这些存储<code>key</code>和<code>value</code>的具体的值，在Redis中是通过<code>RedisObject</code>来统一保存的</li>\n<li>我们又具体介绍了RedisObject的结构，当值为Long 类型整数时，<code>RedisObject</code> 中的指针就直接赋值为整数数据了。而其余所有类型的值的地址，都是通过ptr指针来统一保存的。而<code>RedisObject</code>中的<code>type</code>和<code>encoding</code>，告诉我们值的具体的数据类型和编码形式。</li>\n<li>不同的数据类型，包括字符串、集合、链表等都有各自具体的底层实现。我们也一一介绍了。</li>\n<li>从最开始到最后，想带你完整的串一遍Redis主流数据结构从开始到最后的实现。</li>\n<li>相信读到这里后，你肯定能回答出开篇我们提出的问题了：</li>\n</ol>\n</li>\n</ul>\n<p></p>\n        \n<ul>\n<li>Callback<ul>\n<li>你有想过，当你往Redis中写入一个键值对，或者读取一个键值对的时候，数据在Redis中是如何存储及寻址的么？Now, It’s your time.</li>\n</ul>\n</li>\n</ul>\n<p></p>\n        \n    \n<ul>\n<li><p>参考资料</p>\n<ul>\n<li><p><a href=\"https://time.geekbang.org/column/intro/100017301?tab=catalog\">数据结构与算法之美_算法实战_算法面试-极客时间</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/column/intro/100056701\">Redis核心技术与实战_Redis_缓存_集群_分布式数据库_键值数据库-极客时间</a></p>\n</li>\n<li><p><a href=\"https://redis.io/docs/latest/develop/data-types/\">Understand Redis data types</a></p>\n</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":" 开篇 你有想过，当你往Redis中写入一个键值对，或者读取一个键值对的时候，数据在Redis中是如何存储及寻址的么？ 如果你还不清楚或者有兴趣了解，请带着问题...","permalink":"/post/redis-data-type","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Feng","slug":"blog-author","avatar":"https://betterfeng.cn/avatar_feng.jpg","link":"/","description":"Stay focused, be present.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Mac开发大杀器之iTerm+NeoVim+Tmux","uid":"e5bcd557a969ca5425cbf4b6fbc100b6","slug":"Mac开发大杀器之iTerm-NeoVim-Tmux","date":"2024-04-16T10:51:19.000Z","updated":"2024-04-17T02:45:02.145Z","comments":true,"path":"api/articles/Mac开发大杀器之iTerm-NeoVim-Tmux.json","keywords":null,"cover":null,"text":"Mac高效开发组合技iTermTmuxNeoVim","permalink":"/post/Mac开发大杀器之iTerm-NeoVim-Tmux","photos":[],"count_time":{"symbolsCount":25,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Feng","slug":"blog-author","avatar":"https://betterfeng.cn/avatar_feng.jpg","link":"/","description":"Stay focused, be present.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}