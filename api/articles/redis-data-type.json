{"title":"多图预警-帮你你读懂Redis的主流数据结构","uid":"32c1e1e7d9d0fa312578902346745f87","slug":"redis-data-type","date":"2024-09-26T12:07:27.000Z","updated":"2024-09-26T12:11:16.809Z","comments":true,"path":"api/articles/redis-data-type.json","keywords":null,"cover":[],"content":"<h1 id=\"多图预警-帮你你读懂Redis的主流数据结构\"><a href=\"#多图预警-帮你你读懂Redis的主流数据结构\" class=\"headerlink\" title=\"多图预警-帮你你读懂Redis的主流数据结构\"></a>多图预警-帮你你读懂Redis的主流数据结构</h1><ul>\n<li><p>开篇</p>\n  <aside>\n  💡\n  \n<p>  你有想过，当你往Redis中写入一个键值对，或者读取一个键值对的时候，数据在Redis中是如何存储及寻址的么？</p>\n<p>  如果你还不清楚或者有兴趣了解，请带着问题往下阅读，相信这篇文章会帮你梳理一下思路。</p>\n  </aside>\n  \n</li>\n<li><p>全局哈希表</p>\n<ul>\n<li>哈希表介绍<ul>\n<li>哈希表是由数组扩展而来，利用了数组支持按照下标随机访问的特性。</li>\n<li>当你要在Reids中设置一个键值对的时候，比如<code>set testkey hello_world</code> . Redis通过预设的哈希函数把的键映射为下标，此时为testkey，然后将数据存储在数组中对应下标的位置。比如下图中的5号位置。</li>\n<li>当我们按照键来查询元素值时，我们用同样的哈希函数，将键转化为数组下标5，从对应的数组下标的位置取出我们存储数据。</li>\n</ul>\n</li>\n<li>Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项包含0个多个<code>entry</code>，entry就是一个称为dictEntry的结构体，用来指向一个键值对的值的位置。注意：新来的同学，这里的entry里保存的不是上述的具体值，即<code>键-testkey和值-hello_world，</code>而是保存的存储这两个具体值的地址。如下图：<em>key和</em>value是指针，存储的是地址。</li>\n</ul>\n<p>  <img src=\"/img/avatar_feng.jpg\" alt=\"image.png\">\n  </p>\n</li>\n<li><p><code>dictEntry</code> 结构中有三个 8 字节的指针，分别指向 key对应的<code>RedisObject</code>对象、value 对应的<code>RedisObject</code>对象以及下一个 <code>dictEntry</code>。那RedisObject是何方神圣呢？且往后看：</p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%201.png\" alt=\"image.png\"></p>\n</li>\n<li><p><code>dictEntry</code>中有指向key和value的指针，这个指针就是指向各自对应的<code>RedisObject</code>。所以可以说Redis键值对中的key和value的具体值的访问都是从<code>RedisObject</code>开始的。以下是<code>RedisObject</code>的具体结构</p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%202.png\" alt=\"image.png\"></p>\n</li>\n<li><p>Reids中键的数据类型统一为String，也是基于RedisObject来保存。为了节省内存空间，Redis 还对 Long 类型整数和 <code>SDS</code> （Simple Dynamic String - 简单动态字符串）的内存布局做了专门的设计。</p>\n<ul>\n<li>当保存的是 <code>Long</code> 类型整数时，<code>RedisObject</code> 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li>\n<li>当保存的是字符串数据，并且字符串小于等于 44 字节时，<code>RedisObject</code> 中的元数据、指针和 <code>SDS</code> 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 <code>embstr</code> 编码方式。</li>\n<li>当字符串大于 44 字节时，<code>SDS</code> 的数据量就开始变多了，Redis 就不再把 <code>SDS</code> 和 <code>RedisObject</code> 布局在一起了，而是会给 <code>SDS</code> 分配独立的空间，并用指针指向 <code>SDS</code> 结构。这种布局方式被称为 raw 编码模式。</li>\n</ul>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%203.png\" alt=\"image.png\">\n  </p>\n</li>\n<li><p>众所周知，Redis的键值对中的值除了字符串，还包含一些复杂的集合类型，比如链表、哈希等。所以这些复杂类型的地址都是用<code>*ptr</code>来寻址的。以下为不同的值的数据类型对应的具体的底层实现：</p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%204.png\" alt=\"image.png\"></p>\n</li>\n<li><p>当值的数据类型为<code>String</code>时，与键的底层实现一致。（这里再贴一下示意图，大家就不用再往回翻了~）</p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%203.png\" alt=\"image.png\"></p>\n</li>\n<li><p>当值的数据类型为<code>hash/list/sorted set</code>，且底层实现为压缩列表时，<code>*ptr</code>指向底层的<strong>压缩列表的起始地址</strong>（即压缩列表的头部）。</p>\n<ul>\n<li>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。</li>\n<li>每个 <code>entry</code> 的元数据包括下面几部分。<ul>\n<li><code>prev_len</code>，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。</li>\n<li><code>len</code>：表示自身长度，4 字节；</li>\n<li><code>encoding</code>：表示编码方式，1 字节；</li>\n<li><code>content</code>：保存实际数据。</li>\n</ul>\n</li>\n<li>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</li>\n</ul>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%205.png\" alt=\"image.png\">\n  </p>\n</li>\n<li><p>当值的数据类型为<code>hash/set</code>，且底层实现为<code>hash</code>表时，<code>ptr</code> 会直接指向哈希表结构的起始位置。通过这个指针，Redis 可以访问和操作哈希表中的数据。如下所示：</p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%206.png\" alt=\"image.png\"></p>\n</li>\n<li><p>当 Redis 中的值的类型是 **<code>set</code>**，且底层实现为 <strong>整数集合（<code>intset</code>）</strong> 时，<code>redisObject</code> 结构体的 <code>*ptr</code> 指针指向整数集合的起始地址。整数集合是一个紧凑的、无序的数据结构，专门用来存储整数，并且可以自动调整存储整数的大小以节省空间。在这里指向的就是<code>a[0]</code>的起始地址<code>1000</code></p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%207.png\" alt=\"image.png\"></p>\n</li>\n<li><p>当值的类型为<code>sorted set</code>，且底层实现为跳表时，<code>ptr</code> 指针指向一个包含两部分的结构体：</p>\n<ol>\n<li><strong>跳表（<code>skiplist</code>）</strong>：负责按分数顺序存储所有元素。</li>\n<li><strong>字典（<code>dict</code>）</strong>：负责存储成员到分数的映射，以支持 <code>O(1)</code> 时间复杂度的分数查找和存在性检查。</li>\n</ol>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%208.png\" alt=\"image.png\">\n  </p>\n</li>\n<li><p>当值的类型为list，且底层实现为双向链表时，list 类型的 <code>redisObject</code> ，<code>*ptr</code> 指针指向链表的头部节点。这个头部节点包含指向第一个实际数据节点的链接，以及链表的长度和尾部节点的链接。这样的结构设计允许从列表的任一端快速添加或删除元素，提高操作的效率。</p>\n<p>  <img src=\"/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2010dc301276f8807292bfcd4e114d7447/image%209.png\" alt=\"image.png\"></p>\n</li>\n<li><p>总结</p>\n<ol>\n<li><p>我们从Redis的起始全局哈希表开始，明白Redis是怎么组合及保存所有键值对的</p>\n</li>\n<li><p>从具体的全局哈希表中的每一个<code>DictEntry</code>开始，剖析内部组成，重点关注指向<code>key</code>和<code>value</code>的两个指针</p>\n</li>\n<li><p>然后我们开始关注这些存储<code>key</code>和<code>value</code>的具体的值，在Redis中是通过<code>RedisObject</code>来统一保存的</p>\n</li>\n<li><p>我们又具体介绍了RedisObject的结构，当值为Long 类型整数时，<code>RedisObject</code> 中的指针就直接赋值为整数数据了。而其余所有类型的值的地址，都是通过ptr指针来统一保存的。而<code>RedisObject</code>中的<code>type</code>和<code>encoding</code>，告诉我们值的具体的数据类型和编码形式。</p>\n</li>\n<li><p>不同的数据类型，包括字符串、集合、链表等都有各自具体的底层实现。我们也一一介绍了。</p>\n</li>\n<li><p>从最开始到最后，想带你完整的串一遍Redis主流数据结构从开始到最后的实现。</p>\n</li>\n<li><p>相信读到这里后，你肯定能回答出开篇我们提出的问题了：</p>\n<p> 你有想过，当你往Redis中写入一个键值对，或者读取一个键值对的时候，数据在Redis中是如何存储及寻址的么？Now, It’s your time.</p>\n</li>\n</ol>\n</li>\n<li><p>参考资料</p>\n<p>  <a href=\"https://redis.io/docs/latest/develop/data-types/\">Understand Redis data types</a></p>\n<p>  <a href=\"https://time.geekbang.org/column/intro/100017301?tab=catalog\">数据结构与算法之美_算法实战_算法面试-极客时间</a></p>\n<p>  <a href=\"https://time.geekbang.org/column/intro/100056701\">Redis核心技术与实战_Redis_缓存_集群_分布式数据库_键值数据库-极客时间</a></p>\n</li>\n</ul>\n","feature":true,"text":"多图预警-帮你你读懂Redis的主流数据结构 开篇 💡 你有想过，当你往Redis中写入一个键值对，或者读取一个键值对的时候，数据在Redis中是如何存储及寻址...","permalink":"/post/redis-data-type","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6-%E5%B8%AE%E4%BD%A0%E4%BD%A0%E8%AF%BB%E6%87%82Redis%E7%9A%84%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">多图预警-帮你你读懂Redis的主流数据结构</span></a></li></ol>","author":{"name":"Feng","slug":"blog-author","avatar":"https://betterfeng.cn/avatar_feng.jpg","link":"/","description":"Stay focused, be present.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Mac开发大杀器之iTerm+NeoVim+Tmux","uid":"e5bcd557a969ca5425cbf4b6fbc100b6","slug":"Mac开发大杀器之iTerm-NeoVim-Tmux","date":"2024-04-16T10:51:19.000Z","updated":"2024-04-17T02:45:02.145Z","comments":true,"path":"api/articles/Mac开发大杀器之iTerm-NeoVim-Tmux.json","keywords":null,"cover":null,"text":"Mac高效开发组合技iTermTmuxNeoVim","permalink":"/post/Mac开发大杀器之iTerm-NeoVim-Tmux","photos":[],"count_time":{"symbolsCount":25,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Feng","slug":"blog-author","avatar":"https://betterfeng.cn/avatar_feng.jpg","link":"/","description":"Stay focused, be present.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}